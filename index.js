var fs = require('fs');
var spawn = require('child_process').spawn;
var readline = require('readline');
var parseString = require('xml2js').parseString;
var cssJson = require('cssjson');
var mkdirp = require('mkdirp');

// load configuration
var config = require('./config');

var glyphicons = new Array();


var mkdirSync = function (path) {
    mkdirp(path, function (error) {
        if (error){
            console.error(error);
        }        
    });
}

// create folder
mkdirSync(config.bootstrap.svg_output);
mkdirSync(config.bootstrap.tikz_output);
mkdirSync(config.fontawesome.svg_output);
mkdirSync(config.fontawesome.tikz_output);

getSvgTexFromFont(config.bootstrap)
getSvgTexFromFont(config.fontawesome)

function getSvgTexFromFont(config){
    // read glyphicons unicode name from css file
    fs.readFile(config.css_file, function read(error, data) {
        if (error) {
            throw error;
        }

        var cssJsonFile = cssJson.toJSON(data.toString());
        for(var rule in cssJsonFile.children){
            if(rule.indexOf(config.css_prefix) !== -1){
                if(cssJsonFile.children[rule].attributes.content){
                    var glyphiconName = rule.substr(config.css_prefix.length + 1,rule.length).split(':').shift();
                    var glyphiconUnicode = cssJsonFile.children[rule].attributes.content;
                    glyphicons.push({
                        name: glyphiconName,
                        unicode: String.fromCharCode(parseInt(glyphiconUnicode.substr(2,4),16))
                    })
                }
            }
        }

        // read glyphicons svg from file
        var reader = readline.createInterface({
            input: fs.createReadStream(config.font_file)
        });

        var searchEndOfLineFound = false;
        var lineBuffer = '';
        reader.on('line', function(line) {
            if(line.indexOf('<glyph') !== -1 || searchEndOfLineFound){
                lineBuffer += line;
                if(line.indexOf('/>') !== -1){
                    searchEndOfLineFound = false;
                    createSvgAndTex(lineBuffer, config);
                    lineBuffer = '';
                }
                else{
                    searchEndOfLineFound = true;
                }

            }
        });
    });
}

function createSvgAndTex(svgLine, config){
    // parse xml-string
    parseString(svgLine, function(error, result){
        if(error){
            console.log(error);
        }
        else{
            if(result.glyph){
                if(result.glyph.$.unicode){
                    for(var glyphicon in glyphicons){
                        if(glyphicons[glyphicon].unicode === result.glyph.$.unicode){
                            var width, height, translateX, translateY;
                            // check if default is overriden in config.json
                            if(config[glyphicons[glyphicon].name]){
                                var uniqueConfig = config[glyphicons[glyphicon].name];
                                width = uniqueConfig.width || config.default.width;
                                height = uniqueConfig.height || config.default.height;
                                translateX = uniqueConfig.translateX || config.default.translateX;
                                translateY = uniqueConfig.translateY || config.default.translateY;
                            }
                            else{
                                width = config.default.width;
                                height = config.default.height;
                                translateX = config.default.translateX;
                                translateY = config.default.translateY;
                            }
                            // generate svg content
                            var comment = '\n<!-- GENERATED BY glyphicons2tikz from Christian Decker -->\n';
                            var content = '<?xml version="1.0" encoding="UTF-8" standalone="no"?><svg xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" width="' + width + '" height="' + height + '">\n';
                            content += '<g transform="scale(1,-1) translate(' + translateX + ',' + translateY + ')">\n';
                            content += svgLine.replace('glyph ', 'path fill="' + config.color + '" ') + '\n';
                            content += '</g>\n</svg>';
                            content += comment;
                            // save svg file
                            var fileName = config.svg_output + glyphicons[glyphicon].name + ".svg";
                            var tikzFileName = config.tikz_output + glyphicons[glyphicon].name + ".tex";
                            fs.writeFile(fileName, content, function(error) {
                                if(error) {
                                    return console.log(error);
                                }
                                // convert to tikz file
                                console.log('created ' + fileName);
                                var svg2tikz = spawn('svg2tikz',[fileName, '--figonly', '-o', tikzFileName])
                                svg2tikz.stdout.on('data',function(data){
                                    console.log(data.toString());
                                });
                                svg2tikz.stderr.on('data',function(data){
                                    console.log("ERROR with: " + glyphicons[glyphicon].name);
                                });
                                svg2tikz.on('close',function(data){
                                    console.log('created ' + tikzFileName);
                                });
                            });
                        }
                    }
                }
            }
        }
    });
}